% Part 2 program mostly liberated from Hakan Kjellerstrand

% The plan here was for Picat to *try* to find values of the x?? and y??
% inputs such that the z?? outputs don't equal X+Y. If we *can't* find
% such a counterexample, then the set of swaps in the Index array, when
% applied, restores the functioning of the adder network, and gives us our
% puzzle solution.
% Sadly I couldn't find a meaningful way to express that. Proof systems like Liquid
% Haskell, as I understand it, prove statements by testing that the negation of
% the statement is unsatisfiable -- i.e. there is no possible counterexample.
% I couldn't figure out how to express this in Picat while *also* searching for the
% swapped outputs. Instead, the program currently finds individual values of X/Y/Z
% with some swaps that allow the equality X+Y #= Z to hold for those values,
% which says nothing about the generality of the addition.

import sat.
import regex.
import util.

main => read_file_chars().parse.go.

go({Inits,Gate_list}) => 
  Gs = new_map(),
  Regs = [],

  % build a list of variables for all registers + map of register name to its index
  %println(gates=Gate_list),
  foreach([G1,_,G2,Res] in Gate_list)
    %println(group=[G1,G2,Res]),
    foreach (Reg in [G1,G2,Res])
      if not Gs.has_key(Reg) then
        X :: 0..1,
        % maybe something is wrong here?
        Regs := [X|Regs],
        Gs.put(Reg,Regs.len),
      end,
    end,
  end,
  %println(gs=Gs),
  Regs := Regs.reverse, % we put elements in Regs backwards; reverse it to fix Gs

  N = Gs.size,
  Gate_count = Gate_list.len,

  % Outputs maps from gate index to the "true" output register
  Outputs = new_array(Gate_count),
  Outputs :: 0..1,
  % indirection table for gates: most gate indices point to the same index in the outputs
  % Index[I] #!= I implies gate I's output has been swapped with another gate's output
  Index = new_array(Gate_count),
  Index :: 1..Gate_count,
  all_different(Index),
  Swapped = new_array(Gate_count),
  Swapped :: 0..1,

  % encode the instructions
  foreach(I in 1..Gate_count)
    [X,Op,Y,Reg_name] = Gate_list[I],
    Xv = Regs[Gs.get(X)],
    Yv = Regs[Gs.get(Y)],
    K = Gs.get(Reg_name),
    element(K,Regs,Reg),
    %Reg = Regs[K],

    element(I,Index,I2), % I2 is the gate index whose register should be written to
    element(I2,Index,I), % either this gate, or another gate that should write to this reg
    if false && membchk(Reg_name, ["kth","z12","gsd","z26","tbt","z32","vpm","qnf"]) then
      % this makes it unsolvable... am I putting input in backwards or something? something is off.
      println(force_swapping=Gate_list[I]),
      I #!= I2
    end,
    S :: 0..1,
    I #!= I2 #=> S #= 1,
    I #= I2 #=> S #= 0,
    element(I,Swapped,S),
    element(I2,Swapped,S),

    % why does this fail?
    element(I2,Outputs,Reg), % swap destination register to another gate output
    element(I,Outputs,Dest), % true output of this gate (may be a different register)
    S #= 0 #=> Reg #= Dest,  % this doesn't help
    op(Xv,Op,Yv,Dest),
  end,
  exactly(8,Swapped,1),

  % count counterexample...
  Bits = 45, % yeah, hardcode for now
  Counterexample = new_array(1),
  Counterexample :: 0..1,
  Xs = new_array(Bits), Ys = new_array(Bits), Zs = new_array(Bits + 1),
  assign_number(Xs,x,Regs,Gs,X),
  assign_number(Ys,y,Regs,Gs,Y),
  assign_number(Zs,z,Regs,Gs,Z),
  X #> 0, Y #> 0,
  %X1 = random2() mod 2**45,
  %Y1 = random2() mod 2**45,
  % X #= X1, Y #= Y1,
  %X #= 2**45-1, Y #= 2**45-1,
  %X #= 35184372088831,
  %Y #= 33939827265535, % fails at 1 + 4095
  %println([X,Y,X+Y]),
  %Z #= X+Y,
  %Z #= X+Y #=> Fails #= 0,
  %Z #!= X+Y #=> Fails #= 1,
  Fails :: 0..1, % moving this before the above 2 lines breaks the solve?
  % Fails #= 0, % this also breaks the solve
  Err #= abs(X+Y-Z),
  % X = 01010101010101010101010101010101010101010101 (5864062014805)
  % Y = 10101010101010101010101010101010101010101010
  (X+Y #!= Z) #<=> Counterexample[1] #= 1,
  Fails #= sum(Counterexample),
  Fails #= 0, % this just prevents it from finding counterexamples...
  garbage_collect(1000000000),
  %show_all_regs(Gs,Regs),
  println(solving),
  solve([maxsat,$min(Err),$max(Fails)],[X,Y,Z,Fails,Counterexample,Index,Swapped,Regs,Outputs]),
  %show_all_regs(Gs,Regs),
  println([X,Y,Z,abs(X+Y-Z)]),
  println(failed=Fails),
  Reverse_gs = new_map(),
  foreach (K=V in Gs)
    Reverse_gs.put(V,K)
  end,
  Swaps = [],
  foreach (I in 1..Gate_count)
    if Index[I] > I then
      println(swapped=[I,Index[I]]),
      println(Gate_list[I]),
      println(Gate_list[Index[I]]),
      Out1 = Gate_list[I].last,
      Out2 = Gate_list[Index[I]].last,
      Swaps := [Out1|Swaps],
      Swaps := [Out2|Swaps],
    end,
  end,
  println(swaps=Swaps.sort).

show_all_regs(Gs,Regs) =>
  foreach (K in Gs.keys.sort)
    printf("%w = %w\n", K, Regs[Gs.get(K)])
  end.

show_regs(C,Gs,Regs) =>
  printf("%w: ", C),
  foreach (I in 1..46)
    K = to_fstring("%w%02d",C,46-I),
    if Gs.has_key(K) then
      print(Regs[Gs.get(K)])
    else
      print(" ")
    end,
  end,
  nl.

assign_number(Ds,C,Regs,Gs,V) =>
  foreach (I in 1..Ds.len)
    K = to_fstring("%w%02d",C,I-1),
    Reg = Gs.get(K),
    %println(reg=[I,Ds.len-I+1,Reg,K]),
    Ds[Ds.len-I+1] #= Regs[Reg],
  end,
  to_num_unsigned(Ds,V).

op(X,"AND",Y,Z) =>
  Z #= cond(X #= 1 #/\ Y #= 1, 1, 0).

op(X,"OR",Y,Z) =>
  Z #= cond(X #= 0 #/\ Y #= 0, 0, 1).  

op(X,"XOR",Y,Z) =>
  Z #= cond(X #= Y, 0, 1).

bin_to_dec(L) = [2**(L.len-I)*L[I] : I in 1..L.len].sum.
to_num_unsigned(List, Num) =>
  Len = List.len,
  Num #= sum([List[I]*2**(Len-I) : I in 1..Len]).

parse(S) = R =>
  Init = regex_find_all("(.+): (\\d)", S),
  Gates = regex_find_all("(.+) (AND|OR|XOR) (.+) -\\> (\\w+)", S),
  R = {Init,Gates}.
